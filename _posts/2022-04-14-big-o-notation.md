---
layout: single
title: Big O 표기법
categories:
- 에프랩 멘토링 2주차
tags:
- java
---

## 점근 표기법을 사용하는 이유

컴퓨터가 알고리즘 실행하는 시간은 실행 환경마다 다르게 측정된다

**실행 환경을 동일하게 하는 것이 어려움으로 기본 연산의 실행 횟수로 성능을 분석**할 수 있다

```java
public int add(int n) {
  int num = 0;
  for(int i = 0; i < 2n; i++) {
    num += i;
  }
  return num;
}
```

만약 위와 같은 알고리즘이 있을 때, 연산의 실행 횟수는 입력 크기 n에 따라 달라진다

```java
f(n) = 2n
```

반복문에서 입력 크기의 2배 만큼 실행하였으므로 2n번 실행되었다



만약 아래와 같이 알고리즘이 복잡해서 실행시간을 나타내는 방법도 복잡하다면 **연산의 효율성을 비교하기 어려워진다**

```java
f(n) = 8n^3 + 4n^2 + 12
```



## 점근 표기법

점근 표기법 (Asymptotic Notation)은 **함수의 증가 양상을 다른 함수와 비교하는 방법** 중 하나이다

주로 **알고리즘의 복잡도를 단순화하여 비교**할 때 사용된다

![image-20220419230946887](https://raw.githubusercontent.com/bgpark82/image/master/images/image-20220419230946887.png)

위의 예시처럼 실행 횟수가 각각 `f(n) = 2n` 과 `g(n) = 8n^3 + 4n^2 + 12`을 비교해보자

n값이 증가할 수록 `f(n) = 8n^3 + 4n^2 + 12` 함수의 실행횟수가 `g(n) = 2n` 함수의 실행횟수보다 훨씬 더 많음을 알 수 있다.

이는 n이 증가함에 따라 함수 **실행횟수의 증가율의 차이**가 나기 때문이다

즉, 함수의 기울기가 크면 실행횟수의 증가폭도 크며, **n이 증가할 때마다 실행횟수가 많은 느린 함수**가 된다

`f(n) = 8n^3 + 4n^2 + 12`은 시간이 지날 수록 `f(n) = n^3`에 점근적으로 수렴하고

`g(n) = 2n`는 시간이 지날 수록 `g(n) = n`에 점근적으로 수렴한다

즉, 최고차항만 비교해도 어느 것이 더 효율적인 함수임을 알 수 있게 된다



## 점근 표기법의 목표

점근 표기법은 **함수의 증가양상을 단순화하여 다른 함수와 비교하는 것이 목표**이다`

그러므로 최고차항을 제외한 모든 항과 계수를 무시해도 함수의 효율성을 비교할 수 있게 된다



실행 횟수를 나타내는 함수는 복잡하여 비교하기 어렵지만

알고리즘 A : `f(n) = 8n^3 + 4n^2 + 12`

알고리즘 B :`g(n) = 2n



점근 표기법으로 바꾼 함수는 단순히 비교하기 쉽다

알고리즘 A : `f(n) = n^3`

알고리즘 B :`g(n) = n`



즉, **점근 표기법을 사용함으로서 어떤 알고리즘이 더 효율적인지 쉽게 비교**할 수 있다

이는 n의 값을 크게 주었을 때 `f(n) = 8n^3 + 4n^2 + 12` 가 `f(n) = n^3`에 수렴하고 이 값을 넘길 수 없기 때문에 다른 함수와 비교할 수 있다

이때, `f(n) = n^3`을 점근 표기법에서는 점근적 상한 (upper bound)라고 한다

**점근 표기법에서는 점근적 상한**을 Big O라고 한다

Big O 표기법을 사용하는 이유는 **n이 매우 커질 경우 최악의 상황이 되고 이때 알고리즘의 성능을 비교해 볼 수 있기 때문에 사용**한다



## 점근 표기 방법

1. Big O 
   - Big O는 **점근적 상한을 표기**하기 위해 사용된다
2. Big omega
   - Big O는 **점근적 하한을 표기**하기 위해 사용된다
3. Big theta
   - Big O는 **점근적 상한 및 하한을 표기**하기 위해 사용된다

## Big O 표기법의 특징

Big O 표기법의 특징은 다음과 같다

1. 상수항 무시

   Big O 표기법에서 입력값은 충분히 큰 값으로 상수항은 무시가 가능하다

   ```java
   O(2N) = O(N)
   ```

2. 작은 항 무시

   Big O 표기법에서 입력값이 충분히 크므로 지배적인 항을 제외하고는 무시가 가능하다

   ```java
   O(N^2 + N + 1) = O(N^2)
   ```

   

## Big O 표기법의 성능 비교

![image-20220416234858834](https://raw.githubusercontent.com/bgpark82/image/master/images/image-20220416234858834.png)

왼쪽 그래프부터 오른쪽 그래프로 갈 수록 시간이 더 빨라진다

표현하면 아래와 같다

![image-20220416234957738](https://raw.githubusercontent.com/bgpark82/image/master/images/image-20220416234957738.png)

흔히 우리가 사용하는 자료구조에 Big O의 값은 정해져 있다

알고리즘을 풀 때, 자료구조가 상황에서 어떤 시간복잡도를 가지는지 안다면 효율적인 알고리즘을 작성할 수 있을 것이다

![image-20220416234914312](https://raw.githubusercontent.com/bgpark82/image/master/images/image-20220416234914312.png)

## 참고

https://noahlogs.tistory.com/27

https://ko.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/asymptotic-notation