---
layout: single
title: 네트워크
categories:
- 
tags: 
- 
---

네트워크는 **노드(node)와 링크(link)로 연결, 연결되지 않은 집합**을 말한다

처리량(throughput)은 링크를 통해 전달되는 **단위 시간당 데이터 양** (`bps`, byte per second)을 말한다. 처리량은 트래픽, 대역폭 등에 영향을 받는다

지연시간(latency)는 **요청이 처리되는 시간**을 말하며, 두 노드 사이를 **왕복하는데 걸리는 시간**을 말한다

네트워크 토폴로지(network topology)는 **노드와 링크의 연결 형태를 의미**한다

1. 트리 토폴로지 : 트리형태로 배치한 네트워크
2. 버스 토폴로지 : **중앙 통신 회선에 여러개의 노드가 연결되어 공유** (LAN)
3. 스타 토폴로지 : 중앙에 노드를 모두 연결된 네트워크 구성
4. 링형 토폴로지 : 양옆의 노드를 연결하여 고리처럼 네트워크 구성
5. 메시 토폴로지 : 그물망처럼 네트워크 구성, **노드에 장애 허용**, **트래픽 분산처리 가능**

스푸핑은 LAN에서 **패킷을 속여 다른 노드로 보내는 것**을 말한다

네트워크 토폴로지가 중요한 이유는 **병목 현상을 해결하는 기준**이 되기 때문이다

만약 네트워크의 병목이 생긴다면 회선을 추가해서 병목을 해결할 수 있다

병목 현상은 **전체 시스템의 성능이 하나의 요소에 의해 제한을 받는 현상**을 말한다

네트워크 분류는 다음과 같다

1. WAN (Wide Area Network) : 광역 네트워크
2. MAN (Metropolitan Area Network) : 대도시 통신망
3. LAN (Local Area Network) : 근거리 통신망

네트워크 프로토콜은 **노드끼리 데이터를 전달하기 위한 공통 인터페이스**를 말한다



## TCP/IP 4계층

TCP/IP 4계층은 **네트워크에 사용되는 통신 프로토콜의 집합**이다

각 계층은 다른 계층이 변경되었을 때 영향을 받지 않도록 설계되었다

예를들어 TCP를 UDP로 변경한다고 브라우저를 다시 설치할 필요가 없다

1. **어플리케이션 계층** (HTTP, SSH, FTP, DNS) : **데이터의 내용을 확인**해 그에 맞는 서비스를 처리하는 레이어
2. **전송 계층** (TCP, UDP) : **Port로 목적 어플리케이션 계층에 패킷을 전달하는 프로토콜**. 데이터가 제대로 전달안되면 재전송도 한다. 
3. **인터넷 계층** (IP) : **IP로 목적 전송계층에 패킷을 전달**하는 프로토콜. 라우터로 목적지 컴퓨터까지 도달하도록 한다. 
4. **링크/ 네트워크 인터페이스 계층** (ethernet) : 아날로그 신호를 디지털 신호로 변환하는 계층



## TCP

TCP는 패킷사이의 **순서를 보장**하고 **연결지향 프로토콜**을 사용하며 수신여부를 확인하여 **신뢰성**을 가져 정확한 데이터 전달이 필요한 통신에 사용된다.  (**가상회선** 패킷 교환 방식)

- 신뢰성 보장 (3 way handshake)
- 순서 보장 (가상회선 패킷 교환방식)
- 연결 지향

가상회선 패킷 교환방식은 **패킷에 가상회선의 식별자**가 있어 패킷이 **전송된 순서대로 도착**한다



### 3 way handshake

3 way handshake는 서버와 클라이언트가 **통신 전 신뢰성 구축**을 위해 사용된다

1. SYN : **클라이언트가 서버에 SYN 패킷을 보낸다**. (ISN이라는 TCP 연결의 첫번째 패킷에 할당된 임의의 시퀀스 번호를 보낸다)
2. SYN + ACK : **서버는 클라이언트의 SYN를 수신한다** (서버의 ISN과 승인번호로 클라이언트 ISN+1을 보낸다)
3. ACK : **클라이언트는 서버에 ACK 패킷을 보낸다** (승인번호로 서버의 ISN+1을 서버로 보낸다)



### 4 way handshake

4 way handshake는 서버와 클라이언트가 **연결을 해제할 때** 사용된다

1. FIN : **클라이언트가 서버에 FIN 패킷을 보낸다.** (클라이언트는 `FIN_WAIT_1` 상태가 되어 서버의 응답을 기다린다)
2. ACK : **서버는 클라이언트에 ACK 패킷을 보낸다** (서버는 `CLOSE_WAIT` 상태가 되고 클라이언트는 `FIN_WAIT_2` 상태가 된다)
3. FIN : **서버는 일정 시간 후 클라이언트에 FIN 패킷을 보낸다** (서버는 `LAST_ACK` 상태가 된다)
4. ACK : **클라이언트는 서버로 ACK를 보낸다** (클라이언트는 `TIME_WAIT` 상태가 되고 서버는 `CLOSED` 상태가 된다. 이후 연결이 닫힌다)

`TIME WAIT` 은 클라이언트가 일정 시간 이후 `CLOSE`하도록 만든다 (리눅스 60초)

클라이언트가 닫힌 상태로 서버가 **지연패킷을 보내면 무결성 문제**가 발생하기 때문이다



### TCP 헤더

TCP 헤더는 세그먼트 단위로 사용된다

- 송신지 포트 번호
- 수신지 포트 번호
- 컨트롤 비트
- 체크섬

> ***컨트롤 비트***
>
> 컨트롤 비트는 **현재 통신 상태를 표현하는 플래그 역할**을 한다. 
>
> SYN (Synchronization) : 요청 플래그, **접속을 시작할 때 ON으로 시작**한다
>
> ACK (Acknowledgement) : 응답 플래그, **이전 동작을 확인**을 알린다
>
> FIN (Finish) : 데이터 송신이 완료되어 통신을 종료하고 싶다는 것을 알린다. 
>
> ISN (Initial Sequnce Numbers) : 초기 연결 시 사용되는 32비트 고유 번호

데이터를 연속해서 보내면 더 빠르다. 

수신 측은 수신한데이터를 **일시적으로 보관하도록 버퍼도 사용**한다

흐름제어는 수신측 버퍼에 패킷을 쌓는 것과 동시에 이미 버퍼에 쌓인 데이터를 순차적으로 꺼내서 처리한다. 수신측 컴퓨터의 성능이 낮으면 데이터가 들어오는 속도보다 처리하는 속도가 더 느려진다. 수신측은 응답을 보낼 때 윈도우 사이즈를 설정하여 어느정도까지 수신할 수 있는지 손싱자 측에  알려준다. 즉, 흐름제어는 **수신측에서 얼만큼 수용할 수 있는지 송신측에 알려주는 방법**이다







## UDP

UDP는 **단순히 데이터만 전달**한다 (**데이터그램** 패킷 교환 방식)

동영상 스트리밍이나 VoIP 등은 일부 데이터가 누락되거나 왜곡 되어도 큰 문제가 없다. 접속이 맺어졌는지 패킷이 누락되는지는 관심이 없다. UDP 헤더는 송신지 포트 번호, 수신지 포트번호, 패킷 길이와 체크섬만으로 구성된다. 

브로드 캐스트와 멀티캐스트로 **하나의 패킷을 여러 수신지에 전달**한다

데이터그램 패킷 교환방식은 패킷이 **최적 경로로 독립적으로 이동**한다. 그래서 순서가 다를 수 있다

온라인 게임 등에서 UDP를 사용하지만 신뢰성을 높이기 위해 어플리케이션 계층에서 **흐름 제어**(Flow Control) 와 **혼잡 제어**(Congestion Control)를 구현한다 





## 인터넷 계층

인터넷 계층은 장치로 받은 **패킷을 IP 주소로 목적지에 전송**하기 위한 계층이다

상대방이 제대로 받았는지 보장하지 못하기 때문에 전송계층이 대신 해준다



## 링크 계층

링크 계층은 신호로 **실직적인 데이터를 전달**하는 계층이다

물리계층은 LAN을 통해 0과 1로 이루어진 데이터를 보내는 계층을 말한다



## 계층간 데이터 송수신 과정

데이터 송수신 과정에는 **캡슐화**와 **비캡슐화** 과정이 포함된다

캡슐화는 상위계층의 **데이터**를 하위계층으로 가면서 **헤더를 추가**하는 과정을 말한다

> 데이터 -> 세그먼트/데이터그램 (L4 헤더) -> 패킷 (IP 헤더) -> 프레임 (프레임 헤더, 프레임 트레일러)

비캡슐화는 하위계층에서 상위계층으로 가면서 **헤더를 제거**하는 과정을 말한다



# 네트워크 기기

---

네트워크 계층은 기기를 가지고 **상위 계층 기기는 하위 계층 기기(프로토콜)를 처리**할 수 있지만 반대는 불가능하다

- 어플리케이션 계층 : L7 스위치
- 인터넷 계층 : L3 스위치, 라우터
- 링크 계층 : L2 스위치, 브리지
- 물리 계층 : NIC, 리피터

## L7 스위치 (= 로드밸런서)

스위치는 **장비를 연결하여 데이터를 전달하는 장비**이다

L7 스위치는 ***어플리케이션 계층***에서 **로드 밸런서**라고 불리며 **서버의 부하를 분산**한다

**필터링** 기능과 트래픽 **모니터**링이 가능하고 **health check**를 통해 장애가 발생한 서버를 분산 대상에 제외한다

> ***L4 스위치와의 차이***
>
> L4 스위치는 인터넷 계층을 처리하는 장치이다
>
> L4 스위치는 **오직 IP와 Port를 기반으로 트래픽을 분산**한다 (스트리밍이나 메세지 기반을 인식하지 못한다)
>
> L7 스위치는 **IP, Port, URL, HTTP 헤더, Cookie 등으로 트래픽 분산**이 가능하다
>
> AWS에서 L7 스위치 로드밸런싱은 `ALB` (Application), L4 스위치를 이용한 로드밸런싱은 `NLB` (Network)라 부른다

> ***health check***
>
> health check는 서버에 부하를 주지 않을만큼 **전송 주기**와 **재전송 횟수**를 잘 설정해야한다



## 라우터

라우터는 여러개의 네트워크에 데이터를 전송할 **최적의 경로를 하는 장치**이다



## L3 스위치 (=라우터)

L3 스위치는 ***인터넷 계층***에서 **IP 주소**를 **라우팅 테이블**로 관리하여 패킷을 보낸다

L3 스위치는 **L2 스위치**와 **라우터**를 합친 하드웨어 라우터라 부르기도 한다



## L2 스위치

L2 스위치는 ***링크 계층***에서 **MAC 주소**를 **MAC 주소 테이블**로 관리하여 패킷을 전송한다

MAC 주소 테이블에 목적지가 없으면 전체 포트에 패킷을 전달한다



| 이름      | 계층         | 라우팅                | aka        |
| --------- | ------------ | --------------------- | ---------- |
| L7 스위치 | 어플리케이션 | IP, Port, URL, Header | 로드밸런서 |
| L4 스위치 | 전송         | IP, Port              | 로드밸런서 |
| L3 스위치 | 인터넷       | IP                    | 라우터     |
| L2 스위치 | 링크         | MAC                   | 라우터     |



# IP 주소

---

## ARP

ARP(Address Resolution Protocol)은 **IP 주소로 부터 MAC 주소를 매핑하는 프로토콜**이다

즉, ARP로 가상 주소인 IP 주소를 실제 주소인 MAC 주소로 변환한다

ARP 브로드캐스트를 보내 여러 서버 중 IP에 해당하는 MAC 주소를 가진 서버를 찾는다

컴퓨터간 통신은 **ARP를 통해 IP 주소에서 MAC 주소를 찾아 통신**한다



## 홉 바이 홉

hop by hop은 **IP 주소를 통해 통신하는 과정**을 말한다

패킷이 여러 라우터의 라우팅 테이블의 IP를 기반으로 건너가며(hop) 통신한다



## 라우팅 테이블

라우팅 테이블은 **송신지에서 수신지까지 도달하기 위해** 라우터가 **목적지 정보**와 **목적지로 가는 방법**, 게이트웨이의 정보를 기록한 테이블을 말한다



## 게이트웨이

게이트 웨이는 **네트워크 간 통신을 가능하게 하는 관문** 역할을 한다

게이트웨이는 서로 다른 네트워크의 **프로토콜을 변환**하는 역할을 하기도 한다



## IP 주소 체계

IP는 IPv4와 IPv6으로 나뉜다

IPv4는 **32비트를 8비트 단위**로 점을 찍어 표기한다

IPv6는 **64비트를 16비트 단위**로 점을 찍어 표기한다

### 클래스 기반 할당방식

IP 주소 체계는 A,B,C,D,E 클래스로 구분하는 클래스 기반 할당방식(CIDR)을 사용했다

크게 구분비트 + 네트워크 주소 + 호스트 주소로 나누어 사용하고 마지막 주소는 브로드캐스트 주소로 사용된다

- 클래스 A : 구분 비트 0 + 네트워크 7비트 + 호스트 24비트 (0.0.0.0 ~ 127.255.255.255)
- 클래스 B : 구분 비트 10 + 네트워크 14비트 + 호스트 16비트 (128.0.0.0 ~ 191.255.255.255)
- 클래스 C : 구분 비트 110 + 네트워크 21비트 + 호스트 8비트 (192.0.0.0 ~ 223.255.255.255)
- 클래스 D : 멀티 캐스팅
- 클래스 E : 예비용

하지만 이 방식은 **버려지는 주소가 더 많아 DHCP와 IPv6, NAT가 나오게 되었다**

### 서브 마스크

**네트워크 부의 길이를 늘려 호스트의 개수**를 조절한다

예를들어 10.1.1.0/24 네트워크(클래스 C)에서 64개의 서브넷을 할당하려면

10.1.1.1/26으로 32비트 중 26비트를 네트워크부로 선택한다

남은 6비트가 호스트부가 되고 2^6 = 64에 IP가 할당이 가능하다

그럼 24개의 네트워크부에서 26개로 늘린 2개의 비트에서 총 2^2 = 4개의 서브넷을 생성할 수 있다

- **00000000 00000000 00000000 00**000000 = 10.1.1.0 ~ 10.1.1.63

- **00000000 00000000 00000000 01**000000 = 10.1.1.64 ~ 10.1.1.127

- **00000000 00000000 00000000 10**000000 = 10.1.1.128 ~ 10.1.1.195

- **00000000 00000000 00000000 11**000000 = 10.1.1.196 ~ 10.1.1.255

  

## DHCP

TCP/IP가 제대로 동작하려면 각 호스트의 IP 주소가 중복되면 안된다. 

DHCP (Dynamic Host Configuration Protocol)은 **네트워크 호스트들에 대해 IP 주소를 중복되지 않도록 할당**한다

즉,  **LAN 내의 컴퓨터에게 IP 주소를 할당할 때 사용한다**. 호스트가 네트워크로 연결될 때 IP 주소와 서브넷 마스크 등의 정보가 자동으로 설정된다. 

IP 주소와 매개변수를 자동으로 할당하기 위한 프로토콜이다. **네트워크 장치의 IP주소를 인터넷 접속할 때마다 자동으로 할당**한다

라우터, 게이트웨이, 가정용 네트워크에 DHCP 장치로 IP를 자동으로 할당 받는다

***방법***

호스트가 네트워크에 할당되면 **브로드 캐스트 방식으로 DHCP에게 메세지를 보내고, DHCP 서버가 사용가능한 IP 주소를 새로운 호스트에게 알려준다**.



## NAT

NAT (Network Address Translation)은 IPv4로는 IP가 부족하여 **사설 IP를 공용 IP로 변환**한다

**패킷의 IP 정보를 수정하여 다른 주소에 매핑**하는 방법이다. 즉, IP가 부족하여 사설 IP (192.0.0.1)를 생성하고 외부에서는 공용 IP(121.165.124.1)로 사용해야 하므로 사설 IP를 NAT가 공용 IP로 변환해준다. NAT를 사용하는 이유는 여러대의 호스트 각각의 사설 IP로 하나의 공인 IP 주소를 이용하여 인터넷에 접속하기 위함이다. NAT를 이용하여 내부 IP 주소와 외부 IP 주소를 다르게 유지할 수 있어 **내부 네트워크에 대한 보안**도 가능하다

하지만 여러명이 동시에 인터넷에 접속하므로 접속하는 호스트 숫자에 따라 접속속도가 느려질 수 있다



# HTTP

---

HTTP는 **어플리케이션 계층**에서 **웹 통신에 사용하는 프로토콜**이다



## HTTP/1.0

HTTP/1.0은 **요청마다 3 way handshake로 연결**한다

서버에 연결할 때마다 TCP의 3 way handshake를 해야하므로 RTT가 증가한다. **RTT (Round Trip Time)**는 **패킷의 왕복 시간**을 말한다. 이를 해결하기 위해 **한번의 연결로 다수의 요청을 처리**하는 방법을 사용한다

1. **이미지 스플리팅** : 합쳐진 이미지를 한번만 다운받아 css의 position을 이용해 이미지를 표현
2. **코드 압축** : 코드의 개행문자, 빈칸을 없애 코드의 크기를 최소화한다
3. **이미지 base64 인코딩** : 이미지 파일을 64 진법 문자열로 인코딩한다. 이 경우 HTTP 요청을 할 필요가 없다

> 매 요청마다 TCP 연결
>
> - 이미지 압축
> - 코드 압축
> - 이미지 Base 64 인코딩



## HTTP/1.1

HTTP/1.1은 한번 **TCP를 3 way handshake로 연결한 이후 `keep-alive` 옵션으로 여러번 송수신**이 가능하다

TCP 연결 이후 요청을 할 수 있지만 요청이 서버에서 블로킹되면 다른 요청들도 블로킹 되고 헤더가 중복발생하는 문제가 있다

1. **HOL Blocking** (Head Of Line Blocking) : 패킷이 지연될 때 뒤의 패킷도 지연이 발생하는 현상 
2. **무거운 Header** : HTTP/1.1 헤더는 메타데이터가 압축되지 않아 무겁다

> 여러 요청을 TCP 연결 한번
>
> - HOL Blocking
> - 무거운 Header



## HTTP/2

HTTP/2는 HTTP/1.1의 문제인 HOL Blocking을 줄이고 응답시간을 빠르게 할 수 있다

HTTP2는 HTTPS 위에서 동작한다

### 1. 멀티플렉싱

멀티플렉싱은 **여러개의 스트림을 사용하여 송수신**한다

데이터 조각을 **스트림으로 프레임을 보내 송수신하고 조립하는 형태**로 데이터를 전송한다. 단일 연결로 동시적으로 데이터를 보내 HTTP/1.1의 HOL Blocking 문제를 해결한다

### 2. 헤더 압축

HTTP/2는 **허프만 압축 알고리즘**으로 **헤더를 압축하여 전송**한다

허프만 압축 알고리즘은 **문자열을 문자단위로 쪼개 빈도수를 세어 빈도가 높은 정보는 적은 비트를 사용하여 비트양을 줄인다**

### 3. 서버 푸시

서버 푸시는 **클라이언트 요청없이 서버가 리소스를 전송**가능하다

예를들어 html에는 js, css가 있으므로 클라이언트가 html을 요청하면 js와 css를 클라이언트로 푸시한다

> - 멀티 플랙싱 (HOL Blocking 해결)
> - 헤더 압축
> - 서버 푸시



## HTTPS

HTTPS는 **어플리케이션 계층과 전송 계층 사이에 SSL/TLS 계층을 넣은 암호화 통신 프로토콜**을 말한다

![image-20220521195229411](https://raw.githubusercontent.com/bgpark82/image/master/images/image-20220521195229411.png)

### SSL/TSL

SSL/TSL는 **전송 계층에서 보안을 제공하는 프로토콜**이다

클라이언트와 서버가 통신할 때,  **보안 세션을 기반으로 데이터를 암호화** 하여  제 **3자가 메세지를 조작**하지 못하게 한다

인증 메커니즘, 키 교환 암호화, 해싱 알고리즘으로 **보안 세션을 생성**한다

SSL (Secure Socket Layer)는 SSL 1.0, SSL 2.0, SSL 3.0, TLS 1.0, TSL 1.3 버전까지 올라간다

> ***보안 세션***
>
> **보안이 시작되고 끝나는 동안 유지되는 세션**이다
>
> SSL/TSL는 **3 way handshake를 통해 보안 세션을 생성**한다

> ***SSL, TSL***
>
> SSL은 **넷스케이프 커뮤니케이션스가 개발**했고, **IETF는 이를 TLS로 표준화**한 후 기존의 SSL을 대체했다.
>
> 하지만 과거에 SSL이 폭넓게 사용되어 SSL/TSL로 혼용하여 사용되지만 결국 현재는 TLS를 사용한다

### 인증 메커니즘

인증 메커니즘은 **CA(Certificate Authorities)에서 발급한 인증서**를 기반으로 이루어진다

인증 매커니즘 다음과 같다

![image-20220504011004880](https://raw.githubusercontent.com/bgpark82/image/master/images/image-20220504011004880.png)

### 해싱 알고리즘

해싱 알고리즘은 **해시 함수를 통해 데이터를 추정하기 힘들도록 작고 섞인 랜덤한 조각**으로 만드는 알고리즘이다

SSL/TSL은 `SHA-256`과 `SHA-384` 해싱 알고리즘을 사용한다

`SHA-256`은 **해시 함수의 결과가 256비트인 알고리즘**이다 



## HTTP3

HTTP3은 **QUIC 계층**에서 **UDP 기반의 프로토콜**이다

UDP 기반이므로 3 way handshake를 사용할 필요가 없어 **초기 연결시 지연 시간이 적다**





# 보안

---

## OAuth

OAuth (Open Authorization)은 **자신의 리소스를 다른 어플리케이션이 접근하도록 접근권한을 위임**하는 개방형 표준 프로토콜이다

OAuth 이전에는 사용자가 사이트A에서 사이트B의 리소스를 받아오기 위해 아이디와 비밀번호를 직접 입력하여 사용했다

- 사용자 : 사이트A에서 사이트B의 ID와 Password를 알려주는 것을 신뢰할 수 없다
- 사이트A :  ID와 Password를 넘겨받았으므로 보안 문제시 책임을 져야한다
- 사이트B : 사이트A를 신뢰할 수 없다

OAuth는 **사용자가 자신의 사이트B의 리소스를 사이트A가 접근하도록 허용**한다



### 용어

- Resource Server : 사용자의 리소스를 가진 서버 google, naver 등
- Resource Owner : 사용자
- Client : 개발 사이트
- Authorization Server : Resource Server의 (google, naver) 인증서버 



### 인증절차 종류

1. Authorization Code Grant : Authorization 서버에서 받은 코드로 엑세스 토큰을 받는 방식
2. Implicit Grant : Authorization Code Grant와 달리 코드 교환단계 가짐
3. Resource Owner Password : 비밀번호를 사용하여 엑세스 토큰 획득
4. Credential Grant : 아이디와 비밀번호를 받아 Resource 서버에 인증
5. Client Credetntial Grant :  사용자가 외부에서 엑세스 토큰을 얻어 리소스 접근





https://doqtqu.tistory.com/295



## JWT

JWT (Jason Web Token)은 Json 포멧으로 사용자 속성을 저장하는 **Claim 기반의 웹 토큰**이다

JWT 구조는 Header, Payload, Signature로 이루어지고 각 부분은 Bas64URL로 인코딩되어 있다

### 1. Header

Header는 typ과 alg로 구성된다

alg는 **Signature를 해싱하기 위한 알고리즘을 지정**한다. **서명**(Signature) 및 **토큰 검증**을 위해 사용된다

typ은 토큰의 타입을 지정한다 (ex. JWT)

```json
{ 
  "alg": "HS256", 
  "typ": JWT 
}
```

### 2. Payload

Pyaload는 **토큰의 정보 조각인 Claim**이 담겨있고 Key-Value 형태로 정보를 넣을 수 있다

1. 등록된 Claim : 토큰 정보를 표현하기 위해 정해진 데이터
2. 공개 Claim : 공개용으로 사용자가 정의한 데이터
3. 비공기 Claim : 비공개용으로 사용자가 정의한 데이터

### 3. Signature

Signature는 토큰을 인코딩 혹은 유효성 검증을 할 때 사용하는 **고유한 암호화 코드**이다

1. Header와 Payload를 각 **Base64URL 인코딩**한다
2. 인코딩 값을 비밀키를 이용하여 Header의 alg 알고리즘으로 **해싱**을 한다
3. 해싱한 값을 **Base64URL 인코딩**한다

### 고려사항

1. 토큰 자체에 정보를 담으면 보안상의 문제가 될 수 있다
2. 토큰 Payload에 3가지 Claim을 저장하므로 **정보가 많으면 토큰이 길어져 네트워크 부하가 발생**할 수 있다
3. **Payload 자체는 암호화 된게 아니라 Base64URL 인코딩되었으므로 탈취** 당할 수도 있다. JWE로 암호화하거나 중요한 데이터를 넣지 않는다
4. JWT는 상태를 저장하지 않으므로 한번 생성 후 **만료시간을 넣어주어 삭제**되도록 한다

https://mangkyu.tistory.com/56



# 보안

기존의 TCP/IP 기술은 **데이터를 원본으로 전송**한다. 

통신 보안을 강화하기 위해 암호화 기법, 프로토콜들이 개발된다. 

HTTPS 프로토콜은 HTTP에 SSL/TSL라는 암호화 통신 프로토콜을 적용한 것이다. 하지만 HTTPS는 웹 서비스에 국한되므로 이메일 등의 서비스들 또한 다른 방법으로 보호행한다. VPN은 통신 거점간의 통신을 통째로 암호화하는 방식을 사용한다. 

![image-20220521183606836](https://raw.githubusercontent.com/bgpark82/image/master/images/image-20220521183606836.png)

## 1. 암호화

데이터를 암호화하는 방법은 **공유키**와 **공개키** 방식이 있다. 

암호화는 **원본 데이터를 이해하지 못하도록 만드는 작업**이다. 

복호화는 **암호화된 데이터를 원본 데이터로 변경하는 작업**이다. 

키는 **암호화와 복호화를 아무나 하지 못하도록 비밀번호**이다



### 1.1 공유키

![image-20220521184211299](https://raw.githubusercontent.com/bgpark82/image/master/images/image-20220521184211299.png)

공유키는 **하나의 키로 암호화와 복호화**를 한다.

공유키는 암호화 방식이 간단하고 빠르다. 하지만 공개키를 안전하게 공유하는 방법이 어렵다. 공개키가 유출되면 3자가 복호화 가능하기 때문이다. 



### 1.2 공개키

![image-20220521184326263](https://raw.githubusercontent.com/bgpark82/image/master/images/image-20220521184326263.png)

공개키는 **암호화 키와 복호화 키를 별도로 만드는 방법**이다.

공개키는 **상대에게 공개키를 전달해 상대방이 데이터를 암호화**한다. 공개키는 암호화만 하기 때문에 유출되어도 복호화할 수 없다.

개인키는 **본인이 가지고 있으며 암호화된 데이터를 받아 복호화**한다.



## 2. 전자 증명서, 전자 서명

공개키 암호화 방식을 사용하면 데이터 유출은 막을 수 있지만 **공개키를 보낸 사람이 모르는 사람이라면 누군지 모르는 사람에게 데이터를 넘겨줄 수도 있다**

그래서 인터넷에서 데이터를 주고받을 때 **본인이 신뢰받는 사람인지 증명하는 수단**이 필요하다

### 2.1 인증기관, 전자 인증서, 전자 서명

![image-20220521191828054](https://raw.githubusercontent.com/bgpark82/image/master/images/image-20220521191828054.png)

인증기관 (CA, Certification Authority)은 ***전자 인증서*를 발행할 수 있는 자격을 가진 조직**이다. 

전자 인증서는 인증기관으로 발행되어 **공개키 + 전자 서명을 포함**하여 신분 사칭을 막는다

전자 서명은 인증 기관으로 부터 **데이터의 내용이 위변조 되지 않았고, 데이터를 누가 보냈는지 보장**한다.  그래서 인증서를 가진 사람은 증명서에 포함된 공개키를 사용하여 암호화할 수 있다. 전자 서명은 원본 데이터의 hash 값을 구하여 메시지 다이제스트를 생성한 뒤, 개인키로 암호화한 것이다.

> 원본 데이터 -> hash 값 -> 메시지 다이제스트 -> 개인키 암호화 -> 전자서명

공개키로 암호화된 데이터를 보내는 사람이 인증기관에서 발급받은 인증서를 가지지 않는다면 신뢰할 수 없는 사람이라 인지할 수 있다. 

![image-20220521194242331](https://raw.githubusercontent.com/bgpark82/image/master/images/image-20220521194242331.png)

https://m.blog.naver.com/alice_k106/221468341565



### 2.1 PKI

공개키 기반 구조 (PKI, Public Key Infrastructure)는 **공개키나 전자 인증서 등의 보안 인프라**를 말한다. 

즉, **공개키 암호를 사용한 기술** + **인증 기관에 의해 인증을 한 시스템**을 말한다. 

공개키 암호화방식으로 안전하게 데이터를 암호화하고 인증 기관에 의해 신분 사칭 및 데이터 위변조를 막는다



## SSH

SSH (Secure Shell)은 **원격지 서버를 제어**하는 프로토콜이다. telnet을 대체하는 프로토콜이다.

SSL과 마찬가지로 공개키와 공유키를 조합한 방식으로 통신을 암호화한다. 전자 인증서는 사용하지 않는 대신 서버나 클라이언트가 만든 공개키를 사용한다. 방식은 패스워드 인증, 공개키 인증 등이 사용된다. 

### 1. 비밀번호 방식

![image-20220521200040533](https://raw.githubusercontent.com/bgpark82/image/master/images/image-20220521200040533.png)

### 2. 공개키 방식

![image-20220521200810091](https://raw.githubusercontent.com/bgpark82/image/master/images/image-20220521200810091.png)



## 방화벽

방화벽은 **OSI 7 Layer의 네트워크 계층에서 패킷의 IP와 Port정보로 신뢰성 여부를 확인하여 외부로 부터 접근을 차단**할 때 사용한다. 

패킷의 어플리케이션 계층의 데이터와 헤더 (HTTP) + 전송 계층 헤더 (TCP/UDP) + 인터넷 계층 헤더 (IP)를 정보를 통해 제어한다. 

예를들어 TCP 헤더의 포트 범위로 제한하거나 IP 헤더의 IP 주소 범위로 방화벽을 설정할 수 있다. 웹 요청에서 HTTP 프로토콜은 80포트를 사용하므로 패킷의 TCP 헤더 정보를 보고 80포트이면 허용해준다. 혹은 IP 주소를 보고 특정 주소 범위의 IP만 서버로 요청을 허용하도록 한다.

방화벽은 허가된 통신 외에는 모두 차단하므로 허용하는 범위를 잘 관리하는 것이 중요하다. 예를들어, 웹 서버는 HTTP 통신을 하므로 HTTP 요청을 제외한 모든 프로토콜은 방화벽으로 막을 수 있다.

![image-20220521201100504](https://raw.githubusercontent.com/bgpark82/image/master/images/image-20220521201100504.png)

**주요 기능**

- 접근 제어 : 방화벽의 조건에 따라 허용여부를 실행
- 로깅 및 감사 추적 : 사고 발생 시, 출입자를 확인하고 추적하는 기능
- 인증 : 메세지, 사용자를 인증한다
- 암호화 : 한 방화벽에서 다른 방화벽으로 데이터를 암호화해서 전송한다. (VPN)

**단점**

**웹사이트(OSI 7 Layer 중 어플리케이션 레이어)를 향한 공격**과 해킹이 증가하면서 웹사이트 보안에 대한 문제가 대두되었다.

네트워크 레이어는 **암호화된 내용을 복호화할 수 없어서 웹 공격을 방지하는데 한계**를 가진다

**차단**

- Scanning : 어떤 IP 혹은 Port를 사용하는지 스캐닝하는 공격
- IP Spoofing : IP를 속이고 통신하는 공격



## 웹 방화벽

웹 방화벽 (WAF, Web Application Firewell)은 **HTTP 트래픽을 검사해 URL의 문자열을 비교하여 정상여부를 판단하여 OSI 7 Layer의 어플리케이션 계층에 유입되는 해킹을 차단**한다

HTTP 프로토콜만 감시하여 **문자 비교 방식**으로 침입을 차단한다.

***주요기능***

1. URL 단위의 탐지 : 서비스를 제공할 URL만 설정하여 등록되지 않은 URL의 접속을 거부한다. 
2. 파일 업로드 제어 및 파일 검사 : 사용자가 업로드하는 파일의 종류에 따라 업로드 허용여부를 지정. 파일 내용을 검사하여 악의적 공격 형태의 파일은 필터를 통해 차단한다
3. 사용자 개인정보 노출 방지

***차단***

- XSS
- SQL INjection
- Buffer Overflow
- Hacking



## IPS/IDS

침입자 방지 시스템 (IPS, Instruction Protection System)은 **OSI 7 Layer의 전송계층의 보안 시스템**이다

IPS : 침입 **이전** 방지, 실시간 대응, DB 기반

IDS : 침입 **여부** 감지, 실시간 탐지, 로그 기반

***주요 기능***

1. 네트워크에서 발생하는 이벤트 모니터링과 침입 발생 여부를 탐지 또는 대응하는 자동화된 시스템

**차단**

- Worm Virus
- Exploit

https://handreamnet.tistory.com/323?category=694966



## 방화벽 vs 웹 방화벽 vs IPS

![image-20220521233756021](https://raw.githubusercontent.com/bgpark82/image/master/images/image-20220521233756021.png)

- 방화벽 : IP, Port 비교
- 웹 방화벽 : URL 문자열 비교



## Dos vs DDos

Dos (Denial of Service attack) :단일 장치에서 과도한 트래픽을 보내 정상적인 운영이 되지 못하도록 하는 공격

DDos (Distributed Denial of Service attack) : 여러대의 장치에서 과도한 트래픽을 보내 정상적인 운영이 되지 못하도록 하는 공격



## VPN

방화벽은 LAN 내 보안은 구성할 수 있지만. 기업환경에서 본사와 지사처럼 원격 통신을 해야되는 경우가 많은데 보안 프로토콜을 하나하나 사용하는 것은 부담이 될 수 있다. 

VPN(Virtual Private Network)는 **특정 구간의 통신 전체를 안전하게 만드는 기술**이다

VPN에서 사용하는 프로토콜은 다음과 같다

- IPSec (Security Architecture for internet protocol) : **데이터와 IP 헤더를 통째로 암호화하고 새로운 IP 헤더를 사용**한다. 
- PPTP (Point to Point Tunneling Protocol)
- L2TP (Layer 2 Tunneling Protocol)

가정에서 사용하는 컴퓨터나 스마트폰에서는 VPN을 사용할 경우 사용자 인증이 필요하다

