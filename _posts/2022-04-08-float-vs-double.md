---
layout: single
title: 고정 소수점과 부동 소수점의 차이
categories:
- 에프랩 멘토링 1주차
tags: 
- java
---

## double과 float

double과 float 모두 자바에서 사용하는 **실수를 표현**하는 타입이다.

float과 double은 모두 [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754) 표준을 따른다.

float은 32비트 (**4바이트**)를 저장할 수 있다.

double은 64비트 (**8바이트**)를 저장할 수 있다.

## 고정 소수점과 부동 소수점의 차이

고정 소수점과 부동 소수점은 **소수점 아래 실수를 표시하는 방식**을 뜻한다

고정 소수점 (fixed point)는 **고정된 소수점**을 뜻한다. 

예를들어 123.456 처럼 소수점 아래 숫자가 고정된 경우 고정 소수점이라 부른다 (한자어로 부동은 떠올라 움직인다 라는 뜻으로 영어 float을 번역한 것이다)

부동 소수점 (floating point)는 **움직이는 소수점**을 뜻한다

예를들어 1.23456 x 10^2, 12.3456 x 10 처럼 소수점 아래가 변하는 경우 부동 소수점이라 부른다



## 10진수와 2진수

컴퓨터는 0과 1로만 표현이 가능하다

즉, 컴퓨터에서는 2진수를 사용한다

하지만 인간은 10진수를 사용하기 때문에 인간과 컴퓨터간의 간극이 발생한

그렇다면 우리는 10진수를 컴퓨터가 이해하는 2진수로 변환하는 방법을 알아야 한다 

![image-20220411213403099](https://raw.githubusercontent.com/bgpark82/image/master/images/image-20220411213403099.png)

10진수를 2진수로 바꾸는 방법은 10진수의 나머지가 1 혹은 0이 될 때까지 2로 나누어 나머지를 구하고 거꾸로 읽으면 된다

예를들어 10진수 35는 2진수로는 100011이다



## 컴퓨터에서의 실수 표현

컴퓨터는 실수를 어떻게 표현할까?

부동 소수점은 **컴퓨터에서 실수를 표현하는 방법**이다

위의 예처럼 10진수 정수를 컴퓨터가 이해하는 2진수로 변경하는 방법은 간단하다

하지만 **실수는 소수점을 포함**한다

소수점 이하의 10진수를 2진수로 바꾸는 것은 정수와 다르다

소수점 이하의 10진수는 2를 곱해가면서 0과 1를 빼주고 위에서 부터 읽는다

예를들어 0.625는 2진수로 0.101이 된다

- 0.625 * 2 = 1.25 -> 1.25 -**1** = 0.25
- 0.25 * 2 = 0.5 -> 0.5 - **0** = 0.5
- 0.5 * 2 = 1.0 -> 1.0 - **1** = 0

그래서 정확히 표현할 수 있는 부동 소수는 0, 0.25, 0.5, 0.75, 1의 경우밖에 존재하지 않는다

나머지 경우는 조금씩 차이가 생긴다



## 고정 소수점 표현

고정 소수점은 10진수를 2진수로 바꿨을 때, 소수점이 고정된 상태이다

예를들어 7.625라는 실수를 2진수로 변환하면 111.101이다

16비트 체계에서는 맨 앞자리를 부호 비트를 제외하고 7자리의 정수부와 8자리의 소수부로 나뉜다

부호비트(sign bit)는 0이면 양수, 1이면 음수이다

![image-20220409000319218](https://raw.githubusercontent.com/bgpark82/image/master/images/image-20220409000319218.png)

고정 소수점은 아래와 같은 장점이 있다

- 구현하기 쉽다
- 편리하다

하지만 아래와 같은 단점도 존재한다

- 비트 수 대비 표현가능한 수의 범위가 적다
- 범위가 적으므로 정밀도가 떨어진다

고정 소수점은 소수점 자리가 정해져있으므로 정밀한 숫자표현이 불가능하다

그래서 높은 정밀도가 필요없는 작업에서만 사용하도록 유념해야 한다



## 부동 소수점 표현

부동 소수점은 고정 소수점과 다르게 정규화 작업이 추가된다

### 1. 정규화

10 진수의 경우 정규화는 정수부 한자리만 남을 때까지 소수점을 왼쪽으로 이동시키고 이동시킨 만큼 10을 곱한다

```
R = m x 10^n
```

예를들어 10진수 123.456은 1.23456 x 10^2으로 표현할 수 있다



하지만 우리는 컴퓨터를 사용하므로 2진수의 부동 소수점에 관심을 가져야 한다

2 진수의 경우 소수점 아래가 변하는 규칙은 다음과 같다

```
R = m x 2^n
```

예를들어 이진수 101.101은 1.01101 * 2^2로 표현할 수 있다

여기서 소수점을 이동할 수 있다는 의미에서 부동(float) 소수점이라는 용어가 나온 것으로 보인다

### 2. IEEE 754

앞서 float과 double은 IEEE 754표준을 따른다고 하였다

IEEE 754 표준에서는 부동 소수점 방식으로 실수를 저장하는데 32비트 혹은 64비트가 사용된다 



## 왜 돈계산에 쓸 수 없는지

돈은 인간이 사용하는 숫자이므로 10진수로 표현된다

10진수로 돈을 실수로 표현할 때 문제점들을 가진다

예를들어 10원을 3으로 나누면 3.33333.....원으로 정확하게 표현할 수 없게된다 

이처럼 10진수로 특정 분수를 표현하지 못하는 것 처럼 2진수에서도 표현 못하는 실수들이 많다

**컴퓨터는 10진수를 2진수로 처리하므로 정확성 이슈가 발생한다**

0부터 1까지를 2진수 실수로 표현 할 때 0, 0.25, 0.5, 0.75, 1을 제외한 모든 숫자는 2진수로 표현할 때 3.3333....과 같은 정확도의 문제가 발생한다

컴퓨터가 부동 소수점을 처리하는 방식으로 비롯된 문제이다



float과 double은 **이진 부동 소수점 연산에 사용**되며, 넓은 범위의 수를 빠르고 정밀한 **근사치로 계산**하도록 설계되어 있다.

그래서 float과 double은 금융 관련 계산과 맞지 않는다

0.1 혹은 음의 거듭 제곱수 (10^(-10)) 등을 표현할 수 없다 

```java
@Test
void 돈을_계산한다() {
  assertThat(1.03 - 0.42).isEqualTo(0.61);
}
```

![image-20220409001310727](https://raw.githubusercontent.com/bgpark82/image/master/images/image-20220409001310727.png)

예상흔 0.61이 출력될 것 같지만 실제로는 0.6100000000000001이 출력된다

즉, 금융과 관련하여 **소수점 이하를 계산된다면 문제를 야기할 수 있다**



## 해결법

그래서 금융계산에서는 정수로 표현하며 **BigDecimal**, **int** 혹은 **long**을 사용해야 한다

만약 10.25달러를 표현해야 한다면, 1025센트처럼 소수점을 제외한 정수로 표현해야 한다



마지막으로 BigDecimal, int, long의 차이점을 바탕으로 마무리하도록 하겠다.

### BigDecimal

단점

- 기본 타입보다 사용하기 불편하다

- 기본 타입보다 훨씬 느리다

장점

- 8가지 반올림 모드를 가진다

### int 혹은 long

단점

- 값의 크기가 제한된다

  - int : 9자리 10진수


  - long : 18자리 10진수

- 소수점을 직접 관리해야한다
  - 10.1 달러 -> 101 센트

장점

- 성능이 빠르다



정리하면, **소수점을 가지면 BigDecimal**, **소수점이 없으면 int 혹은 long**을 사용한다



## 출처

https://gsmesie692.tistory.com/94

https://sudo-minz.tistory.com/7

https://wedul.site/302

https://hashcode.co.kr/questions/2315/%EB%8F%88%EC%9D%84-%ED%91%9C%EA%B8%B0%ED%95%A0-%EB%95%8C%EB%8A%94-%EC%99%9C-double%EA%B3%BC-float%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EC%95%8A%EB%82%98%EC%9A%94